/*
 * This C++ source file was generated by the Gradle 'init' task.
 */

#include <stdio.h>
#include <stdlib.h>
#include <exception>
#include <memory>
#include <filesystem>

#include "main.h"
#include "luau_executor.h"
#include "lbuild_util.h"
#include "lbuild_target.h"

#include "lua.h"
#include "luacode.h"
#include "lualib.h"

using namespace std;

int main (int argn, char** argv) {
    lua_State* l = luaL_newstate();

    lua_setsafeenv(l, LUA_ENVIRONINDEX, 1);
    luaL_openlibs(l);

    try{
        LBUILD::init_lua(l);
    } catch (std::exception e) {
        const char* str = lua_tostring(l, -1);
        printf("Lua err: %s\n", str);
    }

    // Finalise the lua state
    //luaL_sandbox(l);
    
    filesystem::path build_path("./lbuild.lua");
    if (!filesystem::exists(build_path)){
        fprintf(stderr, "[lbuild error] Unable to find \"%s\" in \"%s\"\n", build_path.filename().c_str(),build_path.parent_path().c_str());
        exit(1);
    }
    
    const char* build_file = build_path.c_str();
    int status = luau_exec::luau_dofile(l, (char*) build_file);

    if (status != LUA_OK){
        const char* err = lua_tostring(l, -1);
        if (err != NULL){
            fprintf(stderr, "lua error: %s\n", err);
        }
        lua_pop(l, -1);
    }
    // Setup the dependencies
    LBUILD::setup_dependencies();

    //printf("argn: %d\n", argn);
    if (argn > 1){
        for (int i = 1; i < argn; i++){
            try{
                LBUILD::run_task(l, argv[i]);
            } catch (std::invalid_argument e){
                fprintf(stderr, "%s is not a valid job\n", argv[i]);
            }
        }
    }

    //std::printf("Hello, World from C++!\n");

    // Cleanup
    LBUILD::BuildTarget::cleanup();
    lua_close(l);
    return 0;
}
